import * as url from 'url';
import { IListParams, IListResult, createTransportError } from 'transport';
import { Author, Article } from 'models';

interface IAuthorListParams extends IListParams {
  readonly query: string;
  readonly match?: 'authors' | 'articles';
  readonly limit?: number;
}

interface IAuthorListResult extends IListResult<Author, IAuthorListParams> {}

async function list(params: IAuthorListParams, jwt?: string): Promise<IAuthorListResult> {
  params = {
    match: 'authors',
    limit: 10,
    ...params
  };

  const response = await fetch(
    url.format({
      protocol: 'https',
      hostname: 'api.journa.io',
      pathname: [params.match, 'search'].map(encodeURIComponent).join('/'),
      query: {
        query: params.query,
        limit: params.limit
      }
    }),
    {
      headers: {
        Cookie: jwt && `id_token=${jwt}`
      },
      cache: 'no-cache',
      credentials: 'include',
      mode: 'cors'
    }
  );

  if (!response.ok)
    throw createTransportError('list', `${response.status}: ${response.statusText}`);
  
  const payload = await response.json();

  return Object.assign(
    payload.results
      // For when the server disobeys our limit, we cap it ourselves.
      .slice(0, params.limit)
      .map(result => {
        const data = {
          id: result.id,
          name: result.fullName
        };
        if (params.match === 'articles')
          Object.assign(data, {
            articlesLoaded: result.relevantArticles.results.map(result => new Article({
              id: result.id,
              title: result.title,
              fullTextUrl: result.fullTextUrl
            })),
            articlesSize: result.relevantArticles.count,
            articlesParams: {
              query: params.query,
              limit: 5
            }
          });
        return new Author(data);
      }),
    { size: payload.count, params }
  );
}

export default { list };
