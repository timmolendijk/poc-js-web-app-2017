import { observable, action, IObservableArray } from 'mobx';
import * as moment from 'moment';
import { reportOnError } from 'error';
import { isTransportError } from 'transport';
import { IAwaitable, awaitProps } from 'await';
import { INormalizable, registerType, IIdentity, Normalizer } from 'normalize';
import { ITransport } from 'transport';
import { Member } from 'models';
import Transport from './transport';

class AttendeeCollection implements IAwaitable {

  constructor(private readonly event: Event, members: ReadonlyArray<IIdentity> = [], normalizer: Normalizer) {
    // TODO(tim): Empty array by default means we cannot distinguish between
    // "unknown" and "empty".
    this.members = members.map(identity => normalizer.instance<Member>(identity));
    this.transport = new Member.Transport(data => normalizer.instance<Member>(Member, data));
  }

  @observable private members: Array<Member>;
  private readonly transport: ITransport<Member>;

  get(): ReadonlyArray<Member> {
    if (!this.members.length && !this.loading)
      // TODO(tim): Don't we have some official API for deferring this to the
      // end of the call stack?
      setTimeout(() => reportOnError(this.load()));

    // TODO(tim): Is this the best place to do this type assertion?
    return (this.members as IObservableArray<Member>).peek();
  }

  @observable private _loading: boolean = false;
  get loading() {
    return this._loading;
  }

  private async load() {
    this.startLoad();
    const page = this.transport.list({ event: this.event });
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }
    this.endLoad(instances);
  }

  @action private startLoad() {
    this._loading = true;
  }
  @action private endLoad(members: ReadonlyArray<Member>) {
    this.members = members.slice();
    this._loading = false;
  }

  get await() {
    // TODO(tim): Implement based on `this.loading` instead?
    return awaitProps(this);
  }

  toJSON() {
    return [...this.members];
  }

}

export default class Event implements INormalizable {

  static readonly Transport = Transport;

  constructor(private readonly normalizer: Normalizer) {
    this.normalizer.onData(this, data => this.data = data);
  }

  private data: any = {};

  // TODO(tim): How to abstract this away?
  private _attendees: AttendeeCollection;
  get attendees() {
    this._attendees = this._attendees || new AttendeeCollection(this, this.data.attendees, this.normalizer);
    return this._attendees;
  }

  get id() {
    return this.data.id;
  }
  get name(): string {
    return this.data.name;
  }
  get pageUrl(): string {
    return this.data.pageUrl;
  }
  get venueName(): string {
    return this.data.venueName;
  }
  get startTime() {
    return moment(this.data.startTime);
  }

  toJSON() {
    return Object.assign(this.data, { attendees: this.attendees });
  }

}

registerType(Event.name, Event);
