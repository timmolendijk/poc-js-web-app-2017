import { observable, action, IObservableArray } from 'mobx';
import * as moment from 'moment';

import { reportOnError } from 'Error';
import { isTransportError } from 'Transport';
import { Awaitable, awaitProps } from 'Awaitable';
import { Normalizable, registerType, Identity, Normalizer } from 'Normalizable';
import { Member, MemberTransport } from 'models';

// TODO(tim): How can we make this awaitable?
class AttendeeCollection implements Awaitable {

  constructor(private readonly event: Event, members: ReadonlyArray<Identity> = [], normalizer: Normalizer) {
    this.members = members.map(identity => normalizer.instance<Member>(identity));
    this.transport = new MemberTransport(data => normalizer.instance<Member>(Member, data));
  }

  @observable private members: Array<Member>;
  private readonly transport: MemberTransport;

  get(): ReadonlyArray<Member> {
    if (!this.members.length && !this.loading)
      // TODO(tim): Don't we have some official API for deferring this to the
      // end of the call stack?
      setTimeout(() => reportOnError(this.load()));

    // TODO(tim): Is this the best place to do this type assertion?
    return (this.members as IObservableArray<Member>).peek();
  }

  @observable private _loading: boolean = false;
  get loading() {
    return this._loading;
  }

  private async load() {
    this.startLoad();
    const page = this.transport.list({ event: this.event });
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }
    this.endLoad(instances);
  }

  @action private startLoad() {
    this._loading = true;
  }
  @action private endLoad(members: ReadonlyArray<Member>) {
    this.members = members.slice();
    this._loading = false;
  }

  get await() {
    // TODO(tim): Implement based on `this.loading` instead?
    return awaitProps(this);
  }

  toJSON() {
    return [...this.members];
  }

}

export class Event implements Normalizable {

  constructor(private readonly normalizer: Normalizer) {
    this.normalizer.onData(this, data => this.data = data);
  }

  private data: any = {};

  // TODO(tim): How to abstract this away?
  private _attendees: AttendeeCollection;
  get attendees() {
    this._attendees = this._attendees || new AttendeeCollection(this, this.data.attendees, this.normalizer);
    return this._attendees;
  }

  get id() {
    return this.data.id;
  }
  get name() {
    return this.data.name;
  }
  get pageUrl() {
    return this.data.pageUrl;
  }
  get venueName() {
    return this.data.venueName;
  }
  get startTime() {
    return moment(this.data.startTime);
  }

  toJSON() {
    return Object.assign(this.data, { attendees: this.attendees });
  }

}

registerType(Event.name, Event);

export default Event;
