import * as React from 'react';
import { renderToString } from 'react-dom/server';
import * as Helmet from 'react-helmet';
import { memoize } from 'lodash';

class Provider extends React.Component<{ addSheet(sheet: string), children? }, { }> {

  static childContextTypes = {
    addSheet: React.PropTypes.func
  };

  getChildContext() {
    return {
      addSheet: this.props.addSheet
    };
  }

  render() {
    return this.props.children;
  }

}

export class Style extends React.Component<{ children? }, { }> {

  constructor(props, context: { addSheet(sheet: string) }) {
    super(props);
    context.addSheet(props.children);
  }

  static contextTypes = {
    addSheet: React.PropTypes.func
  }

  render() {
    return null;
  }

}

type ISingleton = boolean | { [attr: string]: any } 

function Styles({ sheets, singleton = false }: { sheets: ReadonlyArray<string>, singleton?: ISingleton }) {
  let styleTags;
  if (singleton) {
    const styleTag = {
      cssText: sheets.join("\n\n"),
    };
    if (typeof singleton !== 'boolean')
      Object.assign(styleTag, singleton);
    styleTags = [styleTag];
  } else {
    styleTags = sheets.map(sheet => ({ cssText: sheet }));
  }
  return <Helmet style={styleTags} />;
}

interface IServerStyledProps {
  clientContainerId?: string;
  serialize?: boolean;
  singleton?: ISingleton;
  children?;
}

export function ServerStyled({ clientContainerId, serialize = false, singleton, children }: IServerStyledProps) {

  const css = new Set<string>();

  const styledContainerProps: { id?: string } = { };
  if (clientContainerId)
    styledContainerProps.id = clientContainerId;

  // Make sure to follow the exact same DOM structure as in `ClientStyled`.
  const styled = renderToString(<div>
    <Styles sheets={Array.from(css)} />
    <Provider addSheet={css.add.bind(css)}>
      {children}
    </Provider>
  </div>);

  let serializer = null;
  if (serialize)
    serializer = <script dangerouslySetInnerHTML={{
      __html: `window.__CSS__ = ${JSON.stringify(Array.from(css))};`
    }} />;

  return <div>
    <Styles sheets={Array.from(css)} singleton={singleton} />
    <div {...styledContainerProps} dangerouslySetInnerHTML={{ __html: styled }} />
    {serializer}
  </div>;

}

export class ClientStyled extends React.Component<{ children? }, { }> {

  private css = new Set<string>((window as any).__CSS__);

  addSheet = (sheet: string) => {
    const sheetCount = this.css.size;
    this.css.add(sheet);
    if (this.css.size > sheetCount)
      // `addSheet` is usually invoked *during* render, which is why we cannot
      // call `forceUpdate` right away.
      // TODO(tim): Do we really need the `bind` here?
      setTimeout(this.forceUpdate.bind(this));
  }

  render() {
    return <div>
      <Styles sheets={Array.from(this.css)} />
      {this.renderProvider(this.props.children)}
    </div>;
  }

  // TODO(tim): Why does this look so hacky?
  private renderProvider = memoize(function (children) {
    return <Provider addSheet={this.addSheet}>
      {this.props.children}
    </Provider>;
  });

}

