import * as React from 'react';
import { createStore } from 'redux';
import * as mobx from 'mobx';
import { isAwaitable, awaitAll, IAwaitable } from 'await';

function createTypeName(Type) {
  const name = Type.displayName || Type.name;
  if (!name)
    throw new Error("Type needs a name");
  return name;
}

type IReference = [string, string | number | null];

const types = new Map<string, any>();

function getTypeRef(Type) {
  for (const [typeRef, RefType] of types)
    if (RefType === Type)
      return typeRef;
}

// TODO(tim): Merge `typeToIdField` and `typeToFields` into something similar to
// `trackedObjects`.
const typeToIdField = new WeakMap<any, string>();

function getId(object) {
  const Type = object.constructor;
  return typeToIdField.has(Type) ? object[typeToIdField.get(Type)] : null;
}

interface IActionMeta {
  name: string;
  handler: Function;
}

const typeToActions = new WeakMap<any, Array<IActionMeta>>();

export function action(target, name, descriptor) {
  if (!descriptor || !descriptor.value)
    throw new Error("Action decorator can only be applied to method");
  
  const Type = target.constructor;
  const typeRef = createTypeName(Type);
  if (!typeRef)
    throw new Error("Type needs a name")
  if (types.has(typeRef) && types.get(typeRef) !== Type)
    throw new Error("Type reference '${typeRef}' cannot by used by two different types simultaneously");
  types.set(typeRef, Type);

  const actions = typeToActions.get(Type) || [];
  // TODO(tim): Guarantee that `name` is unique.
  actions.push({ name, handler: descriptor.value });
  typeToActions.set(Type, actions);

  // TODO(tim): An alternative (better?) way of implementing this would be to
  // switch the container in "buffer-and-aggregate-all-actions" mode, then
  // simply invoke our action method, and then switch buffer mode off.
  descriptor.value = function (...args) {
    const container = getContainer(this);
    if (container)
      container.dispatch({
        // TODO(tim): Using `.` as splitter is not safe (unless we disallow both
        // type names and action method names from containing a dot).
        type: `@@state/METHOD:${typeRef}.${name}`,
        object: container.createReference(this),
        args: container.serialize(args)
      });
    else
      for (const action of typeToActions.get(Type))
        if (name === action.name) {
          // Never return anything to preserve consistency with action behavior
          // on tracked objects.
          action.handler.apply(this, args);
          break;
        }
  };
}

export function getFields(object) {
  const Type = object.constructor;
  if (typeToFields.has(Type))
    return typeToFields.get(Type).map(field => field.name);
}

const typeToFields = new WeakMap<any, Array<IFieldMeta>>();

interface IFieldConfig {
  dataToValue?: Function;
  valueToData?: Function;
  onTrack?: Function;
  getFieldData?: Function;
  isIdentifier?: boolean;
}

interface IFieldMeta extends IFieldConfig {
  name: string;
}

function hydrate(ref: IReference) {
  const container = getContainer(this);
  return container.getObject(ref);
}

function dehydrate(object): IReference {
  const container = getContainer(this);
  return container.createReference(object);
}

function defaultGetFieldData(name) {
  const container = getContainer(this);
  return container.getField(this, name);
}

function defaultDataToValue(data) {
  return data;
}

function defaultValueToData(value) {
  return value;
}

export function field(config: IFieldConfig = {}) {

  const getFieldData = config.getFieldData || defaultGetFieldData;
  const dataToValue = config.dataToValue || defaultDataToValue;
  const valueToData = config.valueToData || defaultValueToData;
  const isIdentifier = config.isIdentifier || false;

  return (target, name, descriptor) => {
    if (descriptor)
      throw new Error("Field decorator can only be applied to instance property");
    
    const Type = target.constructor;
    const typeRef = createTypeName(Type);
    if (!typeRef)
      throw new Error("Type needs a name")
    if (types.has(typeRef) && types.get(typeRef) !== Type)
      throw new Error("Type reference '${typeRef}' cannot be used by two different types simultaneously");
    types.set(typeRef, Type);

    const fields = typeToFields.get(Type) || [];
    // TODO(tim): Guarantee that `name` is unique and do not store config that
    // is redundant such as `isIdentifier`.
    fields.push(Object.assign({ name }, config));
    typeToFields.set(Type, fields);

    // TODO(tim): Complain if identifier for this type is already defined.
    if (isIdentifier)
      typeToIdField.set(Type, name);

    // TODO(tim): Return descriptor instead of using `Object.defineProperty`?
    Object.defineProperty(target, name, {
      get() {
        const container = getContainer(this);
        if (container)
          // TODO(tim): Every time this getter is invoked, we rerun
          // `dataToValue`, regardless of whether the data has changed to begin
          // with.
          return dataToValue.call(this, getFieldData.call(this, name), hydrate.bind(this));
        else
          // TODO(tim): Why is `getFieldData` not used in this scenario?
          return getUntrackedField(this, name);
      },
      set(value) {
        const container = getContainer(this);
        if (container) {
          if (!isIdentifier)
            container.setField(this, name, valueToData.call(this, value, dehydrate.bind(this)));
        } else {
          setUntrackedField(this, name, value);
        }
      },
      // TODO(tim): Verify these modifiers.
      enumerable: true,
      configurable: true
    });
  };

}

// TODO(tim): Why does it make sense that `identifier` is a field enhancer?
export function identifier(decorator) {
  return (config: IFieldConfig = {}) => {
    return decorator({
      ...config,
      isIdentifier: true
    });
  };
}

// TODO(tim): Naming here would definitely benefit from less generic terminology.
// I actually think we can make this (de)hydration standard behavior of every
// field and even without specifying the shape of the data structure
// (singular vs. plural). We already need this deep-walk logic for serializing
// action method arguments, that's why. Although, there seems to be a subtle
// difference between the (de)hydration that we want here and the
// (de)serialization that is used for action method arguments: dehydration may
// create (add) objects to state, while serialization may never and instead
// attempts to serialize to an alternative "reference" format (type name,
// field data).
export function objects(decorator) {
  return (config: IFieldConfig = {}) => {
    return decorator({
      ...config,
      dataToValue(refs, hydrate) {
        return refs && refs.map(hydrate);
      },
      valueToData(objects, dehydrate) {
        return objects && objects.map(dehydrate);
      }
    });
  };
}

// TODO(tim): Silly hack to make MobX's observable treat each value as scalar.
class Envelope {
  constructor(public readonly value) {}
}

// TODO(tim): Move this to a MobX bindings module.
// TODO(tim): This thing should return a value from observable from its very
// first moment of access, regardless of whether the object is tracked yet or
// not.
export function observable(decorator) {
  // TODO(tim): Do we want to account for the scenario in which `config`
  // contains `getFieldData` (which will overwrite our own implementation here).
  return (config: IFieldConfig = {}) => {
    // TODO(tim): Should this be a map of field names and observables instead?
    // Do we want to account for the use case of invoking the decorator factory
    // once and applying the result more than once?
    const observables = new WeakMap();
    return decorator({
      ...config,
      onTrack(name) {
        const container = getContainer(this);
        // TODO(tim): All this logic here is way too convoluted.
        observables.set(this, mobx.observable(
          new Envelope(container.getField(this, name))
        ));
        container.subscribe(() => {
          const latest = observables.get(this).get().value;
          const current = container.getField(this, name);
          if (latest !== current)
            observables.get(this).set(
              new Envelope(current)
            );
        });
      },
      getFieldData(name) {
        // TODO(tim): Why not just lazily create the observable here?
        if (observables.has(this))
          return observables.get(this).get().value;
        // TODO(tim): Will this ever be called before we have an observable?
        const container = getContainer(this);
        return container.getField(this, name);
      }
    });
  };
}

interface IUntrackedMeta {
  [field: string]: any;
}

const untrackedObjects = new WeakMap<any, IUntrackedMeta>();

export function getUntrackedField(object, field) {
  return (untrackedObjects.get(object) || {})[field];
}

export function setUntrackedField(object, field, value) {
  const data = untrackedObjects.get(object) || {};
  untrackedObjects.set(object, {
    ...data,
    [field]: value
  });
}

interface ITrackedMeta {
  container: Container;
  ref: IReference;
}

const trackedObjects = new WeakMap<any, ITrackedMeta>();

// TODO(tim): Perhaps move to `Container.get(object)`?
export function getContainer(object): Container {
  if (trackedObjects.has(object))
    return trackedObjects.get(object).container;
}

function objectsReducer(state = {}, action) {
  const [typeRef, objectRef] = action.object;
  if (action.type === '@@state/CREATE') {
    if (objectRef === null)
      return {
        ...state,
        [typeRef]: [action.data]
      };
    return {
      ...state,
      [typeRef]: {
        ...state[typeRef],
        [objectRef]: action.data
      }
    };
  }
  if (action.type === '@@state/UPDATE') {
    if (objectRef === null)
      return {
        ...state,
        [typeRef]: [{
          ...state[typeRef][0],
          ...action.data
        }]
      };
    return {
      ...state,
      [typeRef]: {
        ...state[typeRef],
        [objectRef]: {
          ...state[typeRef][objectRef],
          ...action.data
        }
      }
    };
  }
  return state;
}

export class Container implements IAwaitable {

  // TODO(tim): This container object won't be of any use until a store is
  // instantiated. Can't we do that more automatically?
  private store;

  private pendingState;

  // TODO(tim): Meh.
  private pendingInvoke;

  dispatch(action) {
    if (!this.pendingState)
      return this.store.dispatch(action);
    
    this.pendingState = objectsReducer(this.pendingState, action);
  }

  get subscribe() {
    return this.store.subscribe;
  }

  readonly enhancer = createStore => (reducer, preloadedState) => {
    if (this.store)
      throw new Error("Container enhancer should not be applied more than once");
    
    this.store = createStore((state, action) => {

      state = reducer(state, action);

      if (action.type.startsWith('@@state/')) {

        const type = action.type.substr('@@state/'.length);

        if (type.startsWith('METHOD:')) {
          // TODO(tim): Naively splitting on `.` is not safe at all.
          const [typeRef, methodName] = type.substr('METHOD:'.length).split('.');
          this.pendingState = state['@@state'];
          this.pendingInvoke = [];
          for (const { name, handler } of typeToActions.get(types.get(typeRef)))
            if (name === methodName) {
              const object = this.getObject(action.object);
              handler.apply(object, this.deserialize(action.args));
              break;
            }
          const newState = {
            ...state,
            '@@state': this.pendingState
          };
          this.pendingState = undefined;
          return newState;
        }

        return {
          ...state,
          '@@state': objectsReducer(state['@@state'], action)
        };

      }

      return state;

    }, preloadedState);

    // TODO(tim): Ouch. Fugly hack.
    this.store.subscribe(() => {
      if (!this.pendingInvoke)
        return;
      this.pendingInvoke.forEach(invoke => invoke());
      this.pendingInvoke = undefined;
    });

    return this.store;
  }

  serialize(data) {
    if (data == null)
      return data;

    if (Array.isArray(data))
      return data.map(item => this.serialize(item));

    if (typeof data === 'object') {

      if (data.constructor === Object) {
        const serialized = {};
        for (const key in data) if (data.hasOwnProperty(key))
          serialized[key] = this.serialize(data[key]);
        return serialized;
      }

      if (trackedObjects.has(data))
        return this.createReference(data);
      
      const typeRef = getTypeRef(data.constructor);
      // TODO(tim): Warn or error if `typeRef` does not exist? It means that we
      // have no control over whether serialization is possible or reversible.
      if (typeRef) {
        const dataContent = {};
        (getFields(data) || []).forEach(field => {
          dataContent[field] = this.serialize(getUntrackedField(data, field));
        });
        return [typeRef, dataContent];
      }

    }

    return data;
  }

  deserialize(data) {
    if (data == null)
      return data;
    
    if (Array.isArray(data)) {

      // TODO(tim): This condition for reference (both variants) is not
      // waterproof.
      if (data.length === 2 && types.has(data[0])) {

        if (typeof data[1] === 'object') {
          const Type = types.get(data[0]);
          const object = new Type();
          (getFields(object) || []).forEach(field => {
            setUntrackedField(object, field, this.deserialize(data[1][field]));
          });
          return object;
        }

        return this.getObject(data as IReference);

      }

      return data.map(item => this.deserialize(item));

    }

    if (typeof data === 'object') {

      const deserialized = {};
      for (const key in data) if (data.hasOwnProperty(key))
        deserialized[key] = this.deserialize(data[key]);
      return deserialized;

    }

    return data;
  }

  readonly objects = new Map<IReference, any>();

  private getData(ref: IReference) {
    const [typeRef, objectRef] = ref;
    const state = this.store.getState()['@@state'] || {};
    if (objectRef === null) {
      if (Array.isArray(state[typeRef]) && state[typeRef].length === 1)
        return state[typeRef][0];
    } else {
      return state[typeRef] && state[typeRef][objectRef];
    }
  }

  exists(ref: IReference) {
    return this.getData(ref) !== undefined;
  }

  getField(object, field) {
    const ref = this.createReference(object);
    if (!this.exists(ref))
      return;
    return this.getData(ref)[field];
  }

  setField(object, field, value) {
    const ref = this.createReference(object);
    this.dispatch({
      type: '@@state/UPDATE',
      object: ref,
      data: {
        [field]: value
      }
    });
  }

  getObject(ref: IReference) {
    if (!this.exists(ref))
      return;
    
    if (!this.objects.has(ref)) {
      const [typeRef, objectRef] = ref;
      const Type = types.get(typeRef);
      const object = new Type();
      this.objects.set(ref, object);
      trackedObjects.set(object, {
        container: this,
        ref
      });
    }

    return this.objects.get(ref);
  }

  createReference(object): IReference {
    if (trackedObjects.has(object))
      return trackedObjects.get(object).ref;

    const Type = object.constructor;
    const ref: IReference = [getTypeRef(Type), getId(object)];

    if (!this.exists(ref)) {
      const data = {};
      const fields = typeToFields.get(Type);
      for (const { name, valueToData } of fields)
        data[name] = !valueToData ? object[name] :
          valueToData.call(object, object[name], this.createReference.bind(this));
      this.dispatch({
        type: '@@state/CREATE',
        object: ref,
        data
      });
    } else {
      // TODO(tim): update?
    }

    untrackedObjects.delete(object);

    if (this.objects.has(ref))
      object = this.objects.get(ref);
    else
      this.objects.set(ref, object);
    
    trackedObjects.set(object, {
      container: this,
      ref
    });

    const fields = typeToFields.get(Type);
    for (const { name, onTrack } of fields)
      if (onTrack) {
        if (this.pendingState) {
          this.pendingInvoke.push(onTrack.bind(object, name));
        } else {
          onTrack.call(object, name);
        }
      }
    
    return ref;
  }

  get await() {
    const awaiting = [...this.objects.values()]
      .filter(isAwaitable)
      .map(object => object.await);
    return awaitAll(awaiting);
  }

  toJSON() {
    return this.store.getState();
  }

}

// TODO(tim): Move all this React-related stuff to a dedicated bindings module.

interface IProvide {
  state: Container;
}

export class Provider extends React.Component<IProvide & { children? }, {}> {

  static childContextTypes = {
    state: React.PropTypes.instanceOf(Container)
  };

  getChildContext(): IProvide {
    return {
      state: this.props.state
    };
  }

  render() {
    return <div>{this.props.children}</div>;
  }

}

// TODO(tim): Add type definitions.
export function inject(objects) {
  // TODO(tim): Why not make `objects` a function directly (and pass props to
  // it), and have it return an object with inject names and values.
  return Component => {
    return class extends React.Component<any, {}> {

      static displayName = `inject(${createTypeName(Component)})`;

      static contextTypes = {
        state: React.PropTypes.instanceOf(Container)
      };

      render() {
        const container: Container = this.context.state;
        const normalized = {};
        for (const key in objects) if (objects.hasOwnProperty(key))
          normalized[key] = container.getObject(container.createReference(objects[key](this.props)));
        return <Component {...Object.assign(normalized, this.props)} />;
      }

    };
  };
}
