import * as React from 'react';
import { createStore } from 'redux';
import * as mobx from 'mobx';
import { pick } from 'lodash';

function createTypeName(Type) {
  const name = Type.displayName || Type.name;
  if (!name)
    throw new Error("Type needs a name");
  return name;
}

type IReference = [string, string | number | null];

const types = new Map<string, any>();

function getTypeRef(Type) {
  for (const [typeRef, RefType] of types)
    if (RefType === Type)
      return typeRef;
}

// TODO(tim): Merge `typeToIdField` and `typeToFields` into something similar to
// `trackedObjects`.
const typeToIdField = new WeakMap<any, string>();

function getId(object) {
  const Type = object.constructor;
  return typeToIdField.has(Type) ? object[typeToIdField.get(Type)] : null;
}

// TODO(tim): Are we expecting data here? Or values? What is the difference
// exactly?
export function setFields(object, data) {
  const Type = object.constructor;
  Object.assign(object, pick(data, typeToFields.get(Type).map(field => field.name)));
}

const typeToFields = new WeakMap<any, Array<IFieldMeta>>();

interface IFieldConfig {
  dataToValue?: Function;
  valueToData?: Function;
  onTrack?: Function;
  getFieldData?: Function;
  isIdentifier?: boolean;
}

interface IFieldMeta extends IFieldConfig {
  name: string;
}

function hydrate(ref: IReference) {
  const container = getContainer(this);
  return container.getObject(ref);
}

function dehydrate(object): IReference {
  const container = getContainer(this);
  return container.createReference(object);
}

function defaultGetFieldData(name) {
  const container = getContainer(this);
  return container.getField(this, name);
}

function defaultDataToValue(data) {
  return data;
}

function defaultValueToData(value) {
  return value;
}

export function field(config: IFieldConfig = {}) {

  const getFieldData = config.getFieldData || defaultGetFieldData;
  const dataToValue = config.dataToValue || defaultDataToValue;
  const valueToData = config.valueToData || defaultValueToData;
  const isIdentifier = config.isIdentifier || false;

  return (target, name, descriptor) => {
    if (descriptor)
      throw new Error("Field decorator can only be applied to instance property");
    
    const Type = target.constructor;
    const typeRef = createTypeName(Type);
    if (!typeRef)
      throw new Error("Type needs a name")
    if (types.has(typeRef) && types.get(typeRef) !== Type)
      throw new Error("Type reference '${typeRef}' cannot by used by two different types simultaneously");
    types.set(typeRef, Type);

    const fields = typeToFields.get(Type) || [];
    // TODO(tim): Guarantee that `name` is unique and do not store config that
    // is redundant such as `isIdentifier`.
    fields.push(Object.assign({ name }, config));
    typeToFields.set(Type, fields);

    // TODO(tim): Complain if identifier for this type is already defined.
    if (isIdentifier)
      typeToIdField.set(Type, name);

    Object.defineProperty(target, name, {
      get() {
        const container = getContainer(this);
        if (container)
          return dataToValue.call(this, getFieldData.call(this, name), hydrate.bind(this));
        else
          return getUntrackedField(this, name);
      },
      set(value) {
        const container = getContainer(this);
        if (container) {
          if (!isIdentifier)
            container.setField(this, name, valueToData.call(this, value, dehydrate.bind(this)));
        } else {
          setUntrackedField(this, name, value);
        }
      },
      // TODO(tim): Verify these modifiers.
      enumerable: true,
      configurable: true
    });
  };

}

export function identifier(decorator) {
  return (config: IFieldConfig = {}) => {
    return decorator({
      ...config,
      isIdentifier: true
    });
  };
}

// TODO(tim): Naming here would definitely benefit from less generic terminology.
export function objects(decorator) {
  return (config: IFieldConfig = {}) => {
    return decorator({
      ...config,
      dataToValue(refs, hydrate) {
        return refs.map(hydrate);
      },
      valueToData(objects, dehydrate) {
        return objects.map(dehydrate);
      }
    });
  };
}

// TODO(tim): Move this to a MobX bindings module.
export function observable(decorator) {
  // TODO(tim): Do we want to account for the scenario in which `config`
  // contains `getFieldData` (which will overwrite our own implementation here).
  return (config: IFieldConfig = {}) => {
    // TODO(tim): Should this be a map of field names and observables instead?
    // Do we want to account for the use case of invoking the decorator factory
    // once and applying the result more than once?
    const observables = new WeakMap();
    return decorator({
      ...config,
      onTrack(name) {
        if (!observables.has(this))
          observables.set(this, mobx.observable(mobx.asReference(undefined)));
        const container = getContainer(this);
        observables.get(this).set(container.getField(this, name));
        container.store.subscribe(() =>
          observables.get(this).set(container.getField(this, name))
        );
      },
      getFieldData(name) {
        return observables.get(this).get();
      }
    });
  };
}

interface IUntrackedMeta {
  [field: string]: any;
}

const untrackedObjects = new WeakMap<any, IUntrackedMeta>();

export function getUntrackedField(object, field) {
  return (untrackedObjects.get(object) || {})[field];
}

export function setUntrackedField(object, field, value) {
  const data = untrackedObjects.get(object) || {};
  untrackedObjects.set(object, {
    ...data,
    [field]: value
  });
}

interface ITrackedMeta {
  container: Container;
  ref: IReference;
}

const trackedObjects = new WeakMap<any, ITrackedMeta>();

export function getContainer(object): Container {
  if (trackedObjects.has(object))
    return trackedObjects.get(object).container;
}

function objectsReducer(state = {}, action) {
  const [typeRef, objectRef] = action.object;
  if (action.type === '@@state/CREATE') {
    if (objectRef === null)
      return {
        ...state,
        [typeRef]: [action.data]
      };
    return {
      ...state,
      [typeRef]: {
        ...state[typeRef],
        [objectRef]: action.data
      }
    };
  }
  if (action.type === '@@state/UPDATE') {
    if (objectRef === null)
      return {
        ...state,
        [typeRef]: [{
          ...state[typeRef][0],
          ...action.data
        }]
      };
    return {
      ...state,
      [typeRef]: {
        ...state[typeRef],
        [objectRef]: {
          ...state[typeRef][objectRef],
          ...action.data
        }
      }
    };
  }
  return state;
}

export class Container {

  readonly enhancer = createStore => (reducer, preloadedState) => {
    if (this.store)
      throw new Error("Container enhancer should not be applied more than once");
    
    this.store = createStore((state, action) => {
      state = reducer(state, action);
      if (action.type.startsWith('@@state/'))
        return {
          ...state,
          '@@state': objectsReducer(state['@@state'], action)
        };
      return state;
    }, preloadedState);

    return this.store;
  }

  // TODO(tim): This container object won't be of any use until a store is
  // instantiated. Can't we do that more automatically?
  /*private*/ store;

  readonly objects = new Map<IReference, any>();

  /*private*/ getData(ref: IReference) {
    const [typeRef, objectRef] = ref;
    const state = this.store.getState()['@@state'] || {};
    if (objectRef === null) {
      if (Array.isArray(state[typeRef]) && state[typeRef].length === 1)
        return state[typeRef][0];
    } else {
      return state[typeRef] && state[typeRef][objectRef];
    }
  }

  exists(ref: IReference) {
    return this.getData(ref) !== undefined;
  }

  getField(object, field) {
    const ref = this.createReference(object);
    if (!this.exists(ref))
      return;
    return this.getData(ref)[field];
  }

  setField(object, field, value) {
    const ref = this.createReference(object);
    this.store.dispatch({
      type: '@@state/UPDATE',
      object: ref,
      data: {
        [field]: value
      }
    });
  }

  getObject(ref: IReference) {
    if (!this.exists(ref))
      return;
    
    if (!this.objects.has(ref)) {
      const [typeRef, objectRef] = ref;
      const Type = types.get(typeRef);
      const object = new Type();
      this.objects.set(ref, object);
      trackedObjects.set(object, {
        container: this,
        ref
      });
    }

    return this.objects.get(ref);
  }

  createReference(object): IReference {
    if (trackedObjects.has(object))
      return trackedObjects.get(object).ref;

    const Type = object.constructor;
    const ref: IReference = [getTypeRef(Type), getId(object)];

    if (!this.exists(ref)) {
      const data = {};
      const fields = typeToFields.get(Type);
      for (const { name, valueToData } of fields)
        data[name] = !valueToData ? object[name] :
          valueToData.call(object, object[name], this.createReference.bind(this));
      this.store.dispatch({
        type: '@@state/CREATE',
        object: ref,
        data
      });
    } else {
      // TODO(tim): update?
    }

    untrackedObjects.delete(object);

    if (this.objects.has(ref))
      object = this.objects.get(ref);
    else
      this.objects.set(ref, object);
    
    trackedObjects.set(object, {
      container: this,
      ref
    });

    const fields = typeToFields.get(Type);
    for (const { name, onTrack } of fields)
      if (onTrack)
        onTrack.call(object, name);
    
    return ref;
  }

  get await() {
    // TODO(tim): Await all registered instances that implement `IAwaitable`.
    return undefined as any;
  }

  toJSON() {
    return this.store.getState();
  }

}

interface IProvide {
  state: Container;
}

export class Provider extends React.Component<IProvide & { children? }, {}> {

  static childContextTypes = {
    state: React.PropTypes.instanceOf(Container)
  };

  getChildContext(): IProvide {
    return {
      state: this.props.state
    };
  }

  render() {
    return <div>{this.props.children}</div>;
  }

}

// TODO(tim): Add type definitions.
export function inject(objects) {
  return Component => {
    return class extends React.Component<any, {}> {

      static displayName = `inject(${createTypeName(Component)})`;

      static contextTypes = {
        state: React.PropTypes.instanceOf(Container)
      };

      render() {
        const container: Container = this.context.state;
        const normalized = {};
        for (const key in objects) if (objects.hasOwnProperty(key))
          normalized[key] = container.getObject(container.createReference(objects[key]()));
        return <Component {...Object.assign(normalized, this.props)} />;
      }

    };
  };
}
