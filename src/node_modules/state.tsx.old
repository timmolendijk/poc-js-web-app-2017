import * as React from 'react';
import { observable, computed, autorun, action, reaction, asMap, transaction, toJS } from 'mobx';
import { Provider, inject } from 'mobx-react';
// TODO(tim): Use `recompose/getDisplayName` instead.
import { getDisplayName } from 'recompose';
import { IAwaitable } from 'await';

interface IProvide {
  state: State;
}

export function ProvideState({ state, children }: { state: State, children? }) {
  const providing: IProvide = { state };
  return <Provider {...providing}>
    <div>{children}</div>
  </Provider>;
}

export function injectStore<P>(Store: IType) {
  return (BaseComponent: React.ComponentClass<P> | React.StatelessComponent<P>) =>
    inject<P, P>(({ state }: IProvide, props: P) => Object.assign(
      { store: state.getInstance(Store) },
      props
    ))(BaseComponent);
}

const INSTANCE = Symbol('instance');

export type IReference = string;

function isReference(ref): ref is IReference {
  return typeof ref === 'string';
}

interface IAction {
  context;
  name: string;
  args: ReadonlyArray<any>;
}

interface IReduxStore {
  getState();
  subscribe(listener: Function): Function;
  dispatch<A>(action: A): A;
}

type IPrimitive = boolean | number | string | IReference;

interface IType {
  new (state: State);
  // TODO(tim): Defining `defaultProps` as an interface with index types will
  // not work, which doesn't make intuitive sense. Also, shouldn't this field be
  // required?
  defaultProps?: Object;
}

// TODO(tim): Why a map?
const types = new Map<string, IType>();

export function registerType<C extends IType>(Type: C): C;
export function registerType<C extends IType>(name: string, Type: C): C;
export function registerType(...args) {
  let name, Type;
  if (args.length > 1)
    [name, Type] = args;
  else {
    [Type] = args;
    name = getDisplayName(Type);
  }
  types.set(name, Type);
  return Type;
}

export class State implements IAwaitable {

  constructor(data = {}, enhancer?) {
    this.data = asMap(data);
    this.redux = this.createReduxStore(enhancer);
  }

  @observable private readonly data;

  private readonly redux: IReduxStore;

  @computed get snapshot(): Object {
    return toJS(this.data);
  }

  set snapshot(data: Object) {
    const snapshot = {};

    for (const key in data) if (data.hasOwnProperty(key))
      if (this.data.has(key))
        snapshot[key] = Object.assign(this.data.get(key), data[key]);
      else
        snapshot[key] = data[key];
    
    transaction(() => {
      this.data.clear();
      this.data.merge(snapshot);
    });
  }

  dispatch(action: IAction) {
    this.redux.dispatch(action);
  }

  getProps(instance) {
    // TODO(tim): Give out shallow copy to prevent mutation and allow stripping
    // out instance property?
    return this.data.get(this.getReference(instance));
  }

  private mutators: { [id: string]: Function } = {};
  getMutator(context, name) {
    return this.mutators[JSON.stringify([this.getReference(context), name])];
  }
  defineMutator(context, name, mutator) {
    this.mutators[JSON.stringify([this.getReference(context), name])] = mutator;
  }

  private createReduxStore(enhancer?) {

    const createStore = (reducer): IReduxStore => {

      if (enhancer)
        return enhancer(createStore)(reducer);
      
      let stopObservingSnapshots = null;
      const listeners = new Set<Function>();

      return {

        getState: () => this.snapshot,

        subscribe: (listener: Function) => {
          stopObservingSnapshots = stopObservingSnapshots || reaction(
            () => this.snapshot,
            snapshot => {
              for (const listen of listeners)
                listen();
            }
          );
          listeners.add(listener);
          return () => {
            listeners.delete(listener);
            if (listeners.size === 0) {
              stopObservingSnapshots();
              stopObservingSnapshots = null;
            }
          };
        },

        dispatch: (action: IAction) => {
          // TODO(tim)
          console.log('dispatching', action);
          const mutator = this.getMutator(action.context, action.name);
          mutator.apply(action.context, action.args);
          return action;
        }

      };

    };

    return createStore(snapshot => snapshot);

  }

  getReference(Type: IType): IReference;
  getReference(instance): IReference;
  getReference(from): IReference {
    for (const [name, Type] of types.entries())
      if (from === Type)
        return JSON.stringify(name);
    if (!('id' in from))
      return this.getReference(from.constructor);
    for (const [name, Type] of types.entries())
      if (from.constructor === Type)
        return JSON.stringify([name, from.id]);
  }

  getType(ref: IReference): IType {
    let name = JSON.parse(ref);
    if (typeof name !== 'string')
      name = JSON.parse(name[0]);
    return types.get(name);
  }

  getInstance(ref: IReference, data?);
  getInstance(Type: IType, data?);
  getInstance(from, data?) {
    let ref;
    if (!isReference) {
      const Type = from;
      const instance = new Type(this);
      ref = this.getReference(instance);
    } else {
      ref = from;
    }
    if (this.data.has(ref)) {
      if (!(INSTANCE in this.data.get(ref))) {
        const Type = this.getType(ref);
        this.data.get(ref)[INSTANCE] = new Type(this);
      }
      // TODO(tim): Establish relationship between props type and data type.
      Object.assign(this.data.get(ref), data);
      return this.data.get(ref)[INSTANCE];
    } else {
      // TODO(tim): Throw error in case `ref` includes an instance id?
      const Type = this.getType(ref);
      this.data.set(ref, Type.defaultProps || {});
      // TODO(tim): Establish relationship between props type and data type.
      Object.assign(this.data.get(ref), data);
      this.data.get(ref)[INSTANCE] = new Type(this);
      return this.data.get(ref)[INSTANCE];
    }
  }

  get await() {
    // TODO(tim): Await all registered instances that implement `IAwaitable`.
    return undefined as any;
  }

  toJSON() {
    return this.snapshot;
  }

}
