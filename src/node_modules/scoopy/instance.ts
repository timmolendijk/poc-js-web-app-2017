import * as React from 'react';
import { IIdentifier } from '.';
import Store from './store';
import { IType, registerType } from './type';

const wrappeds = new WeakMap<Object, Instance>();

export default class Instance {

  static get(wrapped: Object): Instance {
    if (!wrappeds.has(wrapped))
      wrappeds.set(wrapped, new Instance(wrapped));
    return wrappeds.get(wrapped);
  }

  protected constructor(private readonly wrapped: Object) {
    this.Type = this.wrapped.constructor as IType;
    registerType(this.Type);

    if (this.wrapped instanceof React.Component)
      this.setStore(Store.get(this.wrapped.context.store));
  }

  get value() {
    return this.wrapped;
  }

  readonly Type: IType;

  private store: Store;

  // TODO(tim): Enforce read-only?
  id: IIdentifier;

  setStore(store: Store) {
    if (this.store === store)
      return;
    
    if (this.store)
      throw new Error("Instance cannot belong to more than one store");
    
    // Before we assign a store try to obtain the wrapped object's identity,
    // because afterwards the `id` field may be querying its value from the
    // store, which won't work at this stage because we are not represented
    // there yet. (Being in the store's state object requires an identity.)
    this.id = (this.wrapped as any).id;

    this.store = store;

    // If the wrapped object doesn't provide an identity, we will create one
    // that is unique within the scope of the store we live in.
    if (this.id == null)
      this.id = this.store.getNextId();

    this.store.onFields(this, this.updateFields);
  }

  private readonly fields = {};

  private readonly updateFields = fields => {
    for (const name of Object.keys(fields)) {
      // TODO(tim): Be more clever about equality.
      if (this.fields[name] === fields[name])
        continue;
      this.fields[name] = fields[name];
      this.notifyOnFieldValue(name, this.fields[name]);
    }
  };

  getFields() {
    return { ...this.fields };
  }

  getFieldValue(name) {
    if (this.store)
      return this.store.getFieldValue(this, name);
    return this.fields[name];
  }

  setFieldValue(name, value) {
    if (this.store)
      this.store.setFieldValue(this, name, value);
    else
      this.updateFields({ [name]: value });
  }

  private readonly listeners = {};
  private notifyOnFieldValue(name, value) {
    const listeners = this.listeners[name] || [];
    for (const listener of listeners)
      listener(value);
  }

  onFieldValue(name, listener) {
    this.listeners[name] = this.listeners[name] || [];
    this.listeners[name].push(listener);
    // TODO(tim): Return unsubscriber.
  }

}
