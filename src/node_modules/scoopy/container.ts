import { createStore, Store } from 'redux';
import { NS, hasHiddenProp, getHiddenProp, setHiddenProp } from '.';

// TODO(tim)
type IStateShape = any;

// TODO(tim): Introduce a (serializable) class type to represent a reference?
// Maybe we can include the `${NS}/type` marker in that case (by letting
// `IRef` inherit from the class type)?
interface IRef {
  // [`${NS}/type`]: 'ref';
  type: string;
  id: number | string;
}

function isRef(ref): ref is IRef {
  return ref != null
    && typeof ref === 'object'
    && ref.constructor === Object
    && ref[`${NS}/type`] === 'ref';
}

const types: { [name: string]: any } = {};

function getTypeName(Type): string {
  // TODO(tim): Guarantee name uniqueness.
  const name = Type.displayName || Type.name;
  if (!name)
    throw new Error("Type needs a name");
  if (name in types && types[name] !== Type)
    throw new Error(`Name '${name}' already in use by other type`);
  types[name] = Type;
  return name;
}

function getNameType(name: string) {
  return types[name];
}

export default class Container {

  constructor(preloadedState?, enhancer?) {
    this.store = createStore(this.reducer, preloadedState, enhancer);
    setHiddenProp(this.store, 'container', this);
  }

  readonly store: Store<IStateShape>;

  private readonly reducer = (state = {}, action) => {
    if (action.type === `${NS}/CREATE`)
      state = {
        ...state,
        [action.ref.type]: {
          ...state[action.ref.type],
          [action.ref.id]: action.data
        }
      };
    if (action.type === `${NS}/UPDATE`)
      state = {
        ...state,
        [action.ref.type]: {
          ...state[action.ref.type],
          [action.ref.id]: {
            ...state[action.ref.type][action.ref.id],
            ...action.data
          }
        }
      };
    return state;
  }

  dispatch(action) {
    return this.store.dispatch(action);
  }

  get subscribe() {
    return this.store.subscribe;
  }

  private readonly objects: WeakMap<IRef, any> = new WeakMap();

  hasObject(ref: IRef): boolean {
    const state = this.store.getState();
    return ref.type in state && ref.id in state[ref.type];
  }

  getObject(ref: IRef) {
    // Hydration of preloaded state is done lazily, at the last opportunity.
    if (!this.objects.has(ref) && this.hasObject(ref)) {
      const Type = getNameType(ref.type);
      const object = new Type();
      setHiddenProp(object, 'container', this);
      this.objects.set(ref, object);
    }
    return this.objects.get(ref);
  }

  // TODO(tim): Memoize?
  getField(object, name) {
    const ref = this.createRef(object);
    return this.hydrate(this.store.getState()[ref.type][ref.id][name]);
  }

  setField(object, name, value) {
    this.dispatch({
      type: `${NS}/UPDATE`,
      ref: this.createRef(object),
      data: { [name]: this.dehydrate(value) }
    });
  }

  private hydrate(data) {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(item => this.hydrate(item));
    
    if (isRef(data))
      return this.getObject(data);

    if (typeof data === 'object') {

      const hydrated = {};
      for (const key in data) if (data.hasOwnProperty(key))
        hydrated[key] = this.hydrate(data[key]);
      return hydrated;

    }

    return data;
  }

  private dehydrate(data) {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(item => this.dehydrate(item));
    
    if (typeof data === 'object') {

      if (data.constructor === Object) {
        const dehydrated = {};
        for (const key in data) if (data.hasOwnProperty(key))
          dehydrated[key] = this.dehydrate(data[key]);
        return dehydrated;
      }

      return this.createRef(data);

    }

    return data;
  }

  private objectIdCounter: number = 1;

  // TODO(tim): Memoize?
  private createRef(object): IRef {
    // TODO(tim): Verify that `object` can be properly referenced: at least a
    // unique type name is required.

    // TODO(tim): This here makes normalization problematic.
    if (!hasHiddenProp(object, 'id'))
      setHiddenProp(object, 'id',
        // TODO(tim): Good idea to fix the id of instances of types that define
        // `getId` or not a good idea?
        hasHiddenProp(object.constructor, 'getId')
          ? getHiddenProp(object.constructor, 'getId')(object)
          : this.objectIdCounter++
      );

    const ref = {
      [`${NS}/type`]: 'ref', 
      type: getTypeName(object.constructor),
      id: getHiddenProp(object, 'id')
    };

    if (!this.hasObject(ref))
      this.dispatch({
        type: `${NS}/CREATE`,
        ref,
        data: getHiddenProp(object, 'fields')
      });
    
    setHiddenProp(object, 'container', this);
    this.objects.set(ref, object);
    
    return ref;
  }

  toJSON() {
    return this.store.getState();
  }

}
