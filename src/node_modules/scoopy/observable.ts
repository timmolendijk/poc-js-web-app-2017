import * as React from 'react';
// TODO(tim): This is fragile.
import storeShape from 'react-redux/lib/utils/storeShape';
import * as mobx from 'mobx';
import Container from './container';
import { NS, getHiddenProp } from '.';

function getContainer(object): Container {
  if (object instanceof React.Component)
    return getHiddenProp(object.context.store, 'container');
}

const observable: PropertyDecorator = <T>(target, name: string | symbol, descriptor?: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> => {
  if (descriptor)
    throw new Error("`observable` decorator can only be applied to instance property");
  
  if (target instanceof React.Component) {
    const Component = target.constructor as React.ComponentClass<any>;
    Component.contextTypes = Component.contextTypes || {
      store: storeShape
    };
  }

  const observables: WeakMap<any, mobx.IObservableValue<T>> = new WeakMap();

  function get() {
    let obs = observables.get(this);
    if (!obs) {
      obs = mobx.observable(mobx.asReference(undefined));
      const container = getContainer(this);
      if (container) {
        mobx.extras.allowStateChanges(true, () =>
          obs.set(container.getField(this, name))
        );
        container.subscribe(() =>
          obs.set(container.getField(this, name))
        );
      }
      observables.set(this, obs);
    }
    return obs.get();
  }

  function set(value) {
    const container = getContainer(this);
    if (container)
      // TODO(tim): Persisting on container instantaneously results in the
      // object's initial field values assignments being turned into Redux
      // actions. Not what we want, because initialization is not state change.
      // On second thought: why isn't it, if lazy loading data is state change?
      container.setField(this, name, value);
  }

  return { get, set, enumerable: true, configurable: false };
};

export default observable;
