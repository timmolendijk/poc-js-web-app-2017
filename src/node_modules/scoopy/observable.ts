import * as React from 'react';
// TODO(tim): This is fragile.
import storeShape from 'react-redux/lib/utils/storeShape';
import * as mobx from 'mobx';
import Container from './container';
import { NS, hasHiddenProp, getHiddenProp, getField, setField, subscribeToField } from '.';

// TODO(tim): This name is a bit misleading - it suggest that it will find the
// container to which an object belongs, but it won't go any near that far.
function getContainer(object): Container {
  if (hasHiddenProp(object, 'container'))
    return getHiddenProp(object, 'container');
  if (object instanceof React.Component)
    return getHiddenProp(object.context.store, 'container');
}

const observable: PropertyDecorator = <T>(target, name: string | symbol, descriptor?: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> => {
  if (descriptor)
    throw new Error("`observable` decorator can only be applied to instance property");
  
  if (target instanceof React.Component) {
    const Component = target.constructor as React.ComponentClass<any>;
    Component.contextTypes = Component.contextTypes || {
      store: storeShape
    };
  }

  const observables: WeakMap<any, mobx.IObservableValue<T>> = new WeakMap();

  function get() {
    let obs = observables.get(this);
    if (!obs) {
      obs = mobx.observable(mobx.asReference(undefined));
      const container = getContainer(this);
      if (container) {
        const updateObservable = () => {
          mobx.extras.allowStateChanges(true, () =>
            obs.set(container.getField(this, name))
          );
        };
        updateObservable();
        // TODO(tim): Updating (including potential hydration run) every single
        // field in the app upon every change of every single field in the app,
        // meh it feels silly :). If we would have a subscribe method for every
        // object in the state that would be perfect.
        container.subscribe(updateObservable);
      } else {
        const updateObservable = () => {
          mobx.extras.allowStateChanges(true, () =>
            obs.set(getField(this, name))
          );
        };
        updateObservable();
        subscribeToField(updateObservable);
      }
      observables.set(this, obs);
    }
    return obs.get();
  }

  function set(value: T) {
    const container = getContainer(this);
    if (container)
      // TODO(tim): Persisting on container instantaneously results in the
      // object's initial field values assignments being turned into Redux
      // actions. Not what we want, because initialization is not state change.
      // On second thought: why isn't it, if lazy loading data is state change?
      container.setField(this, name, value);
    else
      setField(this, name, value);
  }

  return { get, set, enumerable: true, configurable: false };
};

export default observable;
