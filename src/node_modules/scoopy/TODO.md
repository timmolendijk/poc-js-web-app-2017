# Features under Consideration

## Shared Fields

If we want to share state over multiple instances, we currently need this to do so:

```tsx
class EventItemController {

  @observable private expanded: ReadonlyArray<Event> = [];

  isExpanded(event: Event): boolean {
    return this.expanded.indexOf(event) !== -1;
  }

  expand(event: Event) {
    const expanded = new Set(this.expanded);
    expanded.add(event);
    this.expanded = [...expanded];
  }

  collapse(event: Event) {
    const expanded = new Set(this.expanded);
    expanded.delete(event);
    this.expanded = [...expanded];
  }

}

@observer class EventItem extends Component<{ id: IIdentifier, event: Event }, {}> {

  @field private controller = new EventItemController();

  @computed get isExpanded(): boolean {
    return this.controller.isExpanded(this.props.event);
  }
  set isExpanded(value: boolean) {
    this.controller[value ? 'expand' : 'collapse'](this.props.event);
  }

  render() {
    const className = classNames('EventItem', { expanded: this.isExpanded });
    return <div onClick={() => this.isExpanded = true} className={className}>
      <Style>{styles}</Style>
      <p>{this.props.event.name}</p>
      {this.renderExpanded()}
    </div>;
  }

  private renderExpanded() {
    if (!this.isExpanded)
      return null;
    
    return <p>
      {this.props.event.pageUrl}<br />
      {this.props.event.venueName}
    </p>;
  }

}
```

More straight-forward and arguably more readable would be if we could do as follows:

```tsx
@observer class EventItem extends Component<{ id: IIdentifier, event: Event }, {}> {

  @observable.shared private expanded: ReadonlyArray<Event> = [];

  @computed get isExpanded(): boolean {
    return this.expanded.indexOf(this.props.event) !== -1;
  }
  set isExpanded(value: boolean) {
    const expanded = new Set(this.expanded);
    expanded[value ? 'add' : 'delete'](this.props.event);
    this.expanded = [...expanded];
  }

  render() {
    const className = classNames('EventItem', { expanded: this.isExpanded });
    return <div onClick={() => this.isExpanded = true} className={className}>
      <Style>{styles}</Style>
      <p>{this.props.event.name}</p>
      {this.renderExpanded()}
    </div>;
  }

  private renderExpanded() {
    if (!this.isExpanded)
      return null;
    
    return <p>
      {this.props.event.pageUrl}<br />
      {this.props.event.venueName}
    </p>;
  }

}
```

## Named Actions

State management would be more explicit if action types are named like in vanilla Redux:

```ts
class Controller {

  @observable private events: ReadonlyArray<Event>;
  @observable private loadCount: number = 0;

  getEvents<F>(fallback: F = null) {
    if (!this.events && this.loadCount === 0)
      reportOnError(this.load());
    
    return this.events || fallback;
  }

  @pending private async load() {
    const page = Event.transport.list();
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }

    this.endLoad(instances);
  }

  @action private endLoad(events: ReadonlyArray<Event>) {
    this.events = events;
    this.loadCount++;
  }

}
```

Invoking `endLoad` would dispatch an action along the following lines:

```
{
  type: '@@scoopy/Controller.endLoad',
  ref: {
    '@@scoopy': 'ref',
    type: 'Controller',
    id: null
  },
  args: [
    {
      '@@scoopy': 'instance',
      type: 'Event',
      data: {
        id: 13135135,
        name: "AmsterdamJS September",
        venueName: "Publitas HQ",
        startTime: 23513058935
      }
    },
    {
      â€¦
    }
  ]
}
```

Our dispatcher will then invoke the corresponding method implementation, side-track and quietly reduce all actions that are dispatched there and return the resulting aggregate state.


## Enable Making Pending State Explicit

The `@pending` decorator maintains state that is implicit unless we offer a means of making it explicit:

```ts
class Controller {

  @observable private events: ReadonlyArray<Event>;
  @observable loading: boolean = false;

  @pending('loading') async load() {
    const page = Event.transport.list();
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }

    this.events = instances;
  }

}
```
