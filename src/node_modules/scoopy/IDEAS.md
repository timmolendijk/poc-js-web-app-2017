# Features under Consideration

## Shared Fields

If we want to share state over multiple instances, we currently need this to do so:

```tsx
class EventItemController {

  @observable private expanded: ReadonlyArray<Event> = [];

  isExpanded(event: Event): boolean {
    return this.expanded.indexOf(event) !== -1;
  }

  expand(event: Event) {
    const expanded = new Set(this.expanded);
    expanded.add(event);
    this.expanded = [...expanded];
  }

  collapse(event: Event) {
    const expanded = new Set(this.expanded);
    expanded.delete(event);
    this.expanded = [...expanded];
  }

}

@observer class EventItem extends Component<{ id: IIdentifier, event: Event }, {}> {

  @field private controller = new EventItemController();

  @computed get isExpanded(): boolean {
    return this.controller.isExpanded(this.props.event);
  }
  set isExpanded(value: boolean) {
    this.controller[value ? 'expand' : 'collapse'](this.props.event);
  }

  render() {
    const className = classNames('EventItem', { expanded: this.isExpanded });
    return <div onClick={() => this.isExpanded = true} className={className}>
      <Style>{styles}</Style>
      <p>{this.props.event.name}</p>
      {this.renderExpanded()}
    </div>;
  }

  private renderExpanded() {
    if (!this.isExpanded)
      return null;
    
    return <p>
      {this.props.event.pageUrl}<br />
      {this.props.event.venueName}
    </p>;
  }

}
```

More straight-forward and arguably more readable would be if we could do as follows:

```tsx
@observer class EventItem extends Component<{ id: IIdentifier, event: Event }, {}> {

  @observable.shared private expanded: ReadonlyArray<Event> = [];

  @computed get isExpanded(): boolean {
    return this.expanded.indexOf(this.props.event) !== -1;
  }
  set isExpanded(value: boolean) {
    const expanded = new Set(this.expanded);
    expanded[value ? 'add' : 'delete'](this.props.event);
    this.expanded = [...expanded];
  }

  render() {
    const className = classNames('EventItem', { expanded: this.isExpanded });
    return <div onClick={() => this.isExpanded = true} className={className}>
      <Style>{styles}</Style>
      <p>{this.props.event.name}</p>
      {this.renderExpanded()}
    </div>;
  }

  private renderExpanded() {
    if (!this.isExpanded)
      return null;
    
    return <p>
      {this.props.event.pageUrl}<br />
      {this.props.event.venueName}
    </p>;
  }

}
```

## Named Actions

State management would be more explicit if action types are named like in vanilla Redux:

```ts
class Controller {

  @observable private events: ReadonlyArray<Event>;
  @observable private loadCount: number = 0;

  getEvents<F>(fallback: F = null) {
    if (!this.events && this.loadCount === 0)
      reportOnError(this.load());
    
    return this.events || fallback;
  }

  @pending private async load() {
    const page = Event.transport.list();
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }

    this.endLoad(instances);
  }

  @action private endLoad(events: ReadonlyArray<Event>) {
    this.events = events;
    this.loadCount++;
  }

}
```

Invoking `endLoad` would dispatch an action along the following lines:

```
{
  type: '@@scoopy/Controller.endLoad',
  ref: {
    '@@scoopy': 'ref',
    type: 'Controller',
    id: null
  },
  args: [
    {
      '@@scoopy': 'instance',
      type: 'Event',
      data: {
        id: 13135135,
        name: "AmsterdamJS September",
        venueName: "Publitas HQ",
        startTime: 23513058935
      }
    },
    {
      …
    }
  ]
}
```

Our dispatcher will then invoke the corresponding method implementation, side-track and quietly reduce all actions that are dispatched there and return the resulting aggregate state.


## Enable Making Pending State Explicit

The `@pending` decorator maintains state that is implicit unless we offer a means of making it explicit:

```ts
class Controller {

  @observable private events: ReadonlyArray<Event>;
  @observable loading: boolean = false;

  @pending('loading') async load() {
    const page = Event.transport.list();
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }

    this.events = instances;
  }

}
```

Perhaps we should reserve the main decorator factory argument space for labeling, for example to allow differentiating between pending operations that should be blocking the server render and those that shouldn't:

```ts
class Controller {

  @observable private events: ReadonlyArray<Event>;
  @observable loading: boolean = false;

  @pending.set('loading') async load() {
    const page = Event.transport.list();
    let instances;
    try {
      instances = await page;
    } catch (err) {
      if (isTransportError(err))
        return;
      throw err;
    }

    this.events = instances;
  }

}
```


## Less Pitfalls When Dealing with Array Values

Several improvements can be made to make dealing with arrays more intuitive and less tricky.

### Type Restrictions on Field Definitions

It would be very useful if we could prevent fields from being declared of type `Array`, because field *values* are intrinsically immutable.

### Shim Array Mutation Methods to Dispatch Actions

The preceding improvement could be completely leapfrogged if we would provide shimmed mutation methods on arrays to make them dispatch actions to the store and thus make them safe to use.

### Transform Arrays to Array-Like Objects

By transparently transforming (via dehydrate and hydrate) array instances to pseudo-array objects, we would introduce support for custom properties on array field values.

This may be useful for working with custom collection types such as “virtual lists”.


## Support for Stateless Functional Components

We can offer an alternative means of defining a field on a view component via an higher-order component that can be wrapped around a stateless functional component:

```tsx
compose(
  getContext({
    router: PropTypes.object.isRequired
  }),
  fields(props => ({
    controller: new SearchController(props)
  })),
  observer
)(function Search({ router, controller }: { router, controller: SearchController }) {

  return <form onSubmit={onSubmitQuery}>
    <input type="search" value={controller.query} onChange={onChangeQuery}
      placeholder="Lekker zoeken kil!" />
  </form>;

  function onSubmitQuery(e) {
    e.preventDefault();
    router.replaceWith({ query: controller.query });
  }

  function onChangeQuery(e) {
    controller.query = e.currentTarget.value;
  }

});
```

Or, we can go for the less humble approach. Note that the feasibility of this approach depends on whether non-plain objects are respected and preserved by React (and the likes) when passed as property collections to `createElement`.

```tsx
compose(
  getContext({
    router: PropTypes.object.isRequired
  }),
  mapProps(props => new SearchProps(props)),
  observer
)(function Search(props: SearchProps) {

  return <form onSubmit={onSubmitQuery}>
    <input type="search" value={props.query} onChangeQuery={onChangeQuery}
      placeholder="Lekker zoeken kil!" />
  </form>;

  function onSubmitQuery(e) {
    e.preventDefault();
    props.issueQuery();
  }

  function onChangeQuery(e) {
    props.query = e.currentTarget.value;
  }

});
```
