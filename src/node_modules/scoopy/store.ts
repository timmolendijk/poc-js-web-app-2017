import { Store as ReduxStore } from 'redux';
import shallowEqual from 'recompose/shallowEqual';
import { IIdentifier } from '.';
import Instance from './instance';
import { getTypeOfKey, getKeyOfType } from './type';

const NS = '@@scoopy';

interface IRef {
  // `[NS]` is not a valid property definition (yet?)
  '@@scoopy': 'ref';
  type: string;
  id: IIdentifier;
}

interface IExternalState {
  // `[NS]` is not a valid property definition (yet?)
  '@@scoopy': IState;
  [external: string]: any;
}

interface IState {
  [type: string]: {
    [id: string]: {
      [field: string]: boolean | string | number | IRef;
    };
  };
}

function createRef(type: string, id: IIdentifier): IRef {
  // `[NS]` is not recognized as `'@@scoopy'`, which is why the type case is
  // required here.
  return { [NS]: 'ref', type, id } as any;
}

function createRefHash(ref: IRef): string {
  return `${ref.type}:${ref.id}`;
}

export function resetNextId(store: ReduxStore<IExternalState>) {
  Store.get(store).resetNextId();
}

export const enhancer = createStore => (externalReducer, preloadedState) =>
  createStore((state, action) => {
    state = externalReducer(state, action);
    return {
      ...state,
      [NS]: reducer(state[NS], action)
    };
  }, preloadedState);

function reducer(state = {}, action) {
  if (action.type == `${NS}/CREATE`)
    state = {
      ...state,
      [action.ref.type]: {
        ...state[action.ref.type],
        [action.ref.id]: action.data
      }
    };
  if (action.type == `${NS}/UPDATE`)
    state = {
      ...state,
      [action.ref.type]: {
        ...state[action.ref.type],
        [action.ref.id]: {
          ...state[action.ref.type][action.ref.id],
          ...action.data
        }
      }
    };
  return state;
}

const wrappeds = new WeakMap<ReduxStore<IExternalState>, Store>();

export default class Store {

  static get(wrapped: ReduxStore<IExternalState>): Store {
    if (!wrappeds.has(wrapped))
      wrappeds.set(wrapped, new Store(wrapped));
    return wrappeds.get(wrapped);
  }

  protected constructor(private readonly wrapped: ReduxStore<IExternalState>) {
    this.resetNextId();
    this.currentState = this.wrapped.getState()[NS];
    this.wrapped.subscribe(() => {
      this.previousState = this.currentState;
      this.currentState = this.wrapped.getState()[NS];
    });
  }

  private previousState: IState;
  private currentState: IState;

  private nextId;
  
  resetNextId() {
    this.nextId = 1;
  }

  getNextId(): number {
    return this.nextId++;
  }

  // TODO(tim): Keep this map in sync with the actual objects inside
  // `this.currentState`.
  private readonly instances = new Map<string, Instance>();

  hasInstance(ref: IRef): boolean {
    return this.instances.has(createRefHash(ref));
  }

  getInstance(ref: IRef): Instance {
    if (!this.hasInstance(ref) && this.existsInState(ref)) {
      const Type = getTypeOfKey(ref.type);
      const instance = Instance.get(new Type());
      instance.setStore(this, ref.id);
      this.setInstance(ref, instance);
    }
    return this.instances.get(createRefHash(ref));
  }

  setInstance(ref: IRef, instance: Instance) {
    return this.instances.set(createRefHash(ref), instance);
  }

  private isRef(ref: IRef): boolean {
    return typeof ref != null
      && typeof ref == 'object'
      && ref[NS] == 'ref'
      && this.existsInState(ref);
  }

  private getRef(instance: Instance): IRef {
    instance.setStore(this);

    const ref = createRef(getKeyOfType(instance.Type), instance.id);

    if (!this.existsInState(ref))
      this.wrapped.dispatch({
        type: `${NS}/CREATE`,
        ref,
        data: this.dehydrate(instance.getFields())
      });
    
    if (!this.hasInstance(ref))
      this.setInstance(ref, instance);

    return ref;
  }

  private existsInState(ref: IRef): boolean {
    return ref.type in this.currentState
      && ref.id in this.currentState[ref.type];
  }

  getFieldValue(instance: Instance, name: string) {
    return this.hydrate(
      this.currentState[getKeyOfType(instance.Type)][instance.id][name]
    );
  }

  setFieldValue(instance: Instance, name: string, value) {
    const ref = this.getRef(instance);
    const dehydrated = this.dehydrate(value);

    if (shallowEqual(this.currentState[ref.type][ref.id][name], dehydrated))
      return;
    
    this.wrapped.dispatch({
      type: `${NS}/UPDATE`,
      ref,
      data: { [name]: dehydrated }
    });
  }

  onFields(instance: Instance, listener) {
    const typeKey = getKeyOfType(instance.Type);
    this.wrapped.subscribe(() => {
      const previous = this.previousState && typeKey in this.previousState ?
        this.previousState[typeKey][instance.id] : undefined;
      const current = typeKey in this.currentState ?
        this.currentState[typeKey][instance.id] : undefined;

      if (shallowEqual(previous, current))
        return;
      
      const hydrated = {};
      // TODO(tim): Most of these hydrated values can be cached most of the
      // time, but maybe it's up to `this.hydrate` to take care of that.
      for (const name of Object.keys(current))
        hydrated[name] = this.hydrate(current[name]);
      listener(hydrated);
    });
    // TODO(tim): Return unsubscriber.
  }

  // TODO(tim): Can we memoize this somehow?
  private hydrate(data) {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(this.hydrate.bind(this));
    
    if (this.isRef(data))
      return this.getInstance(data).value;

    if (typeof data == 'object') {

      const hydrated = {};
      for (const key in data) if (data.hasOwnProperty(key))
        hydrated[key] = this.hydrate(data[key]);
      return hydrated;

    }

    return data;
  }

  private dehydrate(data) {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(this.dehydrate.bind(this));
    
    if (typeof data == 'object') {

      if (data.constructor === Object) {
        const dehydrated = {};
        for (const key in data) if (data.hasOwnProperty(key))
          dehydrated[key] = this.dehydrate(data[key]);
        return dehydrated;
      }

      return this.getRef(Instance.get(data));

    }

    return data;
  }

  getPending() {
    const pendings = [...this.instances.values()]
      .map(instance => instance.getPending())
      .filter(pending => pending != null);
    
    if (pendings.length === 0)
      return;
    
    return Promise.all(pendings as ReadonlyArray<Promise<any>>);
  }

}
