import { Store as ReduxStore } from 'redux';
import shallowEqual from 'recompose/shallowEqual';
import { NS, IState, IRef } from '.';
import Instance from './instance';
import { getTypeOfKey, getKeyOfType } from './type';

export function reducer(state = {}, action) {
  if (action.type == `${NS}/CREATE`)
    state = {
      ...state,
      [action.ref.type]: {
        ...state[action.ref.type],
        [action.ref.id]: action.data
      }
    };
  if (action.type == `${NS}/UPDATE`)
    state = {
      ...state,
      [action.ref.type]: {
        ...state[action.ref.type],
        [action.ref.id]: {
          ...state[action.ref.type][action.ref.id],
          ...action.data
        }
      }
    };
  return state;
}

function getRefHash(ref: IRef): string {
  return `${ref.type}:${ref.id}`;
}

const wrappeds = new WeakMap<ReduxStore<IState>, Store>();

export default class Store {

  static get(wrapped: ReduxStore<IState>): Store {
    if (!wrappeds.has(wrapped))
      wrappeds.set(wrapped, new Store(wrapped));
    return wrappeds.get(wrapped);
  }

  protected constructor(private readonly wrapped: ReduxStore<IState>) {
    this.currentState = this.wrapped.getState();
    this.wrapped.subscribe(() => {
      this.previousState = this.currentState;
      this.currentState = this.wrapped.getState();
    });
  }

  private previousState: IState;
  private currentState: IState;

  private idCounter = 0;
  getNextId() {
    return ++this.idCounter;
  }

  // TODO(tim): Keep this map in sync with the actual objects inside
  // `this.currentState`.
  private readonly instances = new Map<string, Instance>();

  hasInstance(ref: IRef): boolean {
    return this.instances.has(getRefHash(ref));
  }

  getInstance(ref: IRef): Instance {
    return this.instances.get(getRefHash(ref));
  }

  setInstance(ref: IRef, instance: Instance) {
    return this.instances.set(getRefHash(ref), instance);
  }

  private isRef(ref: IRef): boolean {
    return typeof ref != null
      && typeof ref == 'object'
      && ref[NS] == 'ref'
      && this.existsInState(ref);
  }

  private getRef(instance: Instance): IRef {
    instance.setStore(this);

    const ref = {
      [NS]: 'ref',
      type: getKeyOfType(instance.Type),
      id: instance.id
    };

    if (!this.existsInState(ref))
      this.wrapped.dispatch({
        type: `${NS}/CREATE`,
        ref,
        data: this.dehydrate(instance.getFields())
      });
    
    if (!this.hasInstance(ref))
      this.setInstance(ref, instance);

    return ref;
  }

  private existsInState(ref: IRef): boolean {
    return ref.type in this.currentState
      && ref.id in this.currentState[ref.type];
  }

  getFieldValue(instance: Instance, name: string) {
    return this.hydrate(
      this.currentState[getKeyOfType(instance.Type)][instance.id][name]
    );
  }

  setFieldValue(instance: Instance, name: string, value) {
    // TODO(tim): Bail out if value has not changed.
    this.wrapped.dispatch({
      type: `${NS}/UPDATE`,
      ref: this.getRef(instance),
      data: { [name]: this.dehydrate(value) }
    });
  }

  onFields(instance: Instance, listener) {
    const typeKey = getKeyOfType(instance.Type);
    this.wrapped.subscribe(() => {
      const previous = this.previousState && typeKey in this.previousState ?
        this.previousState[typeKey][instance.id] : undefined;
      const current = typeKey in this.currentState ?
        this.currentState[typeKey][instance.id] : undefined;

      if (shallowEqual(previous, current))
        return;
      
      const hydrated = {};
      // TODO(tim): Most of these hydrated values can be cached most of the
      // time, but maybe it's up to `this.hydrate` to take care of that.
      for (const name of Object.keys(current))
        hydrated[name] = this.hydrate(current[name]);
      listener(hydrated);
    });
    // TODO(tim): Return unsubscriber.
  }

  // TODO(tim): Can we memoize this somehow?
  private readonly hydrate = data => {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(this.hydrate);
    
    if (this.isRef(data))
      return this.getInstance(data).value;

    if (typeof data == 'object') {

      const hydrated = {};
      for (const key in data) if (data.hasOwnProperty(key))
        hydrated[key] = this.hydrate(data[key]);
      return hydrated;

    }

    return data;
  };

  private readonly dehydrate = data => {
    if (data == null)
      return data;
    
    if (Array.isArray(data))
      return data.map(this.dehydrate);
    
    if (typeof data == 'object') {

      if (data.constructor === Object) {
        const dehydrated = {};
        for (const key in data) if (data.hasOwnProperty(key))
          dehydrated[key] = this.dehydrate(data[key]);
        return dehydrated;
      }

      return this.getRef(Instance.get(data));

    }

    return data;
  };

}
