import * as React from 'react';
import { observable, computed, asFlat, toJS, action as mobxAction } from 'mobx';
// TODO(tim): Use `recompose/getDisplayName` instead.
import { getDisplayName, shallowEqual } from 'recompose';
import { cloneDeep } from 'lodash';

const $component = Symbol('component');

type IProps = any;

/**
 * State entry representing a component instance.
 * 
 * Note that this type also includes the actual component instance, although not
 * specified. It lives in a property on the tuple array, keyed by symbol
 * `$component`.
 */
type IEntry = [string, IProps];

interface IComponentConstructor {
  new (state?: Container): IComponent;
  defaultProps?: IProps;
}

export interface IComponent {
  id?: string;
}

export type IReference = [string, string | number | boolean];

interface ISerializableComponent {
  toJSON(): ISerializable;
}

interface ISerializableArray extends ReadonlyArray<ISerializable> {}

type ISerializable = string | number | boolean | void | ISerializableComponent | ISerializableArray | IComponent;

interface IAction {
  component: IComponent;
  name: string;
  args: ReadonlyArray<ISerializable>;
}

const types = new Map<string, IComponentConstructor>();

export function registerType(Type: IComponentConstructor) {
  const key = getDisplayName(Type as any);
  if (types.has(key))
    return;//throw new Error(`Type with key '${key}' already registered`);
  types.set(key, Type);
}

function getTypeKey(Type: IComponentConstructor): string {
  for (const [key, T] of types)
    if (Type === T)
      return key;
}

const actors = new Map<string, Function>();

function registerActor(Type: IComponentConstructor, name: string, fn: Function) {
  // TODO(tim)
  registerType(Type);
  const key = getActorKey(Type, name);
  if (!actors.has(key))
    actors.set(key, fn);
}

function getActorKey(Type: IComponentConstructor, name: string): string {
  return JSON.stringify([getTypeKey(Type), name]);
}

export function action(target, name: string, descriptor: PropertyDescriptor) {
  registerActor(target.constructor, name, descriptor.value);
  descriptor.value = function (this: IComponent, ...args) {
    if ((this as any).state)
      return (this as any).state.action(this, name, ...args);
    else
      actors.get(getActorKey(this.constructor as IComponentConstructor, name)).apply(this, args);
  };
}

export class Container {

  constructor(state = []) {
    this.state = asFlat(state.map(([typeName, data]) => {
      const props = this.createProps(data);
      const entry: IEntry = [typeName, props];
      const Type = types.get(typeName);
      entry[$component] = new Type(this);
      return entry;
    }));
  }

  // TODO(tim): Putting this here allows us to easily make this configurable at
  // some point in the future. How can we make this type-safe? What we would
  // like to be able to express is: `keyof IComponent` but only if that key has
  // a type that is `ISerializable`.
  private readonly identifier = 'id';

  @observable private readonly state: Array<IEntry>;

  @computed get snapshot() {
    return toJS(this.state);
  }

  // TODO(tim): These do not need to be on the class definition.
  private createProps(data: IProps): IProps {
    return observable(asFlat(cloneDeep(data)));
  }
  private updateProps(props: IProps, data: IProps): IProps {
    return Object.assign(props, data);
  }

  private readonly unpersisted: WeakMap<IComponent, IProps> = new WeakMap();
  // TODO(tim): Account for duplicate instances of same identity?
  getProps(component: IComponent): IProps {
    for (const entry of this.state)
      if (entry[$component] === component)
        return entry[1];
  }

  private createReference(component: IComponent): IReference {
    // If component defines an identifier it is clearly not an instance of a
    // singleton type, so we require it to have value that has some capacity to
    // distinguish.
    if (this.identifier in component && component[this.identifier] == null)
      throw new Error(`Cannot create reference for component with empty identifier '${this.identifier}'`);
    
    return [
      getTypeKey(component.constructor as IComponentConstructor),
      component[this.identifier]
    ];
  }

  private getData(component: IComponent): { [name: string]: ISerializable } {
    return this.getProps(component) ||
      'toJSON' in component ? (component as any).toJSON() :
      this.createProps((component.constructor as any).defaultProps);
  }

  persistComponent(candidate: IComponent): IReference {
    for (const entry of this.state) {
      const component: IComponent = entry[$component];
      if (this.equals(component, candidate)) {
        // this.updateProps(entry[1], this.getData(candidate));
        return this.createReference(component);
      }
    }

    const entry: IEntry = [
      getTypeKey(candidate.constructor as IComponentConstructor),
      this.getData(candidate)
    ];
    entry[$component] = candidate;
    this.state.push(entry);
    return this.createReference(candidate);
  }

  // // TODO(tim): Offer generics variable that determines return type.
  // getComponent(Type: IComponentConstructor, data?): IComponent {
  //   const candidate = new Type(this);
  //   const props = this.updateProps(this.createProps(Type.defaultProps), data);
  //   this.candidates.set(candidate, props);

  //   for (const entry of this.state) {
  //     const component: IComponent = entry[$component];
  //     if (this.equals(component, candidate)) {
  //       if (data)
  //         // TODO(tim): Do we have to do this asynchronously?
  //         Object.assign(entry[1], data);
  //       return component;
  //     }
  //   }

  //   const entry: IEntry = [getTypeKey(Type), props];
  //   entry[$component] = candidate;
  //   this.state.push(entry);
  //   return candidate;
  // }

  // TODO(tim): Offer generics variable that determines return type.
  getComponent([typeName, componentIdentity]: IReference): IComponent {
    for (const entry of this.state) {
      const component: IComponent = entry[$component];
      if (entry[0] === typeName && component[this.identifier] === componentIdentity)
        return component;
    }
  }

  equals(a: IComponent, b: IComponent) {
    return shallowEqual(this.createReference(a), this.createReference(b));
  }

  action(component: IComponent, name: string, ...args: Array<ISerializable>) {
    console.log('===ACTION===', getTypeKey(component.constructor as IComponentConstructor), name, args);
    const fn = actors.get(getActorKey(component.constructor as IComponentConstructor, name));
    if (fn)
      return mobxAction(fn).apply(component, args);
  }

  get await(): Promise<any> | void {
    return;
  }

  toJSON() {
    return this.snapshot;
  }

}

interface IProvide {
  state: Container;
}

export class Provider extends React.Component<IProvide & { children? }, {}> {

  static childContextTypes = {
    state: React.PropTypes.instanceOf(Container)
  };

  getChildContext() {
    return {
      state: this.props.state
    };
  }

  render() {
    return <div>{this.props.children}</div>;
  }

}

interface IInject {
  store?: IComponent;
}

// TODO(tim): Overload with implementations for multiple or differently named
// property injects.
export function inject<P>(Store: IComponentConstructor) {
  // TODO(tim): Use a `Partial<IInject>` for outside interface.
  return (BaseComponent: React.ComponentClass<P & IInject & { children? }> | React.StatelessComponent<P & IInject & { children? }>) =>
    class extends React.Component<P & IInject & { children? }, {}> {

      static readonly displayName = `inject(${getDisplayName(BaseComponent)})`;

      // constructor(props) {
      //   super(props);

      // }

      // private store: Store;

      static contextTypes = {
        state: React.PropTypes.instanceOf(Container)
      };

      render() {
        const state: Container = this.context.state;
        const inject: IInject = {
          store: state.getComponent(state.persistComponent(new Store(state)))
        };
        return <BaseComponent {...Object.assign(inject, this.props)} />;
      }
    }
}
